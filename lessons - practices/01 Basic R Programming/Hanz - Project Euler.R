library(here)

# PROBLEM 1
# =========
# If we list all the natural numbers below 10 that are multiples
# of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
# 
# Find the sum of all the multiples of 3 or 5 below 1000.

numbers <- 1:1000
target_numbers <- numbers[1:1000 %% 5 == 0 | 1:1000 %% 3 == 0]

# three lines solution + creating 'numbers' and 'target_numbers'
sum(target_numbers)

# two lines solution + creating 'numbers'
sum(numbers[1:1000 %% 5 == 0 | 1:1000 %% 3 == 0])

# one line solution
sum(c(1:1000)[1:1000 %% 5 == 0 | 1:1000 %% 3 == 0])



# PROBLEM 7
# =========
# By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, 
# we can see that the 6th prime is 13.
# 
# What is the 10,001st prime number?

.total_length <- 10001
    # the length of prime numbers, for starter use 6 
    # a dotted variable means
    # that it'll be a hidden variable

primes  <- c(2, vector(length = .total_length-1))

.n  <- 3     # first number to check if this a prime number
.current_length <- 1  # total prime numbers withing the 'primes'
                      # variable, not the zero values

while (any(primes == 0)) {
  # Check if the number can be divided by values under it or not
  .test_if_prime   <- .n %% 2:(.n - 1) == 0
  # print(.n)
  # print(as.numeric(.test_if_prime))
  
  # Check if the number is a prime number, or cannot be divided
  # by any number below it
  if ( sum(.test_if_prime) == 0 ) {
    # assign the prime number into 'primes' var
    primes[.current_length+1] <- .n
    # add 1 to the length of prime numbers within ;primes' var
    .current_length <- .current_length + 1
  }
  
  # check for the next number in the next iteration
  .n <- .n + 1
}

sum(primes == 0) # buat ngeliat brp nilai ada nol di var 'primes'
tail(primes)
primes[10001]
# write.csv(primes, here("datasets/10001 prime numbers.csv"))

13 %% 2:(13-1) == 0
?any



# PROBLEM 39
# ==========
# If p is the perimeter of a right angle triangle with integral
# length sides, {a,b,c}, there are exactly three solutions for 
# p = 120.
# 
# {20,48,52}, {24,45,51}, {30,40,50}
# 
# For which value of p ≤ 1000, is the number of solutions maximised?

20+48+52 == 120
24+45+51 == 120 
30+40+50 == 120
hypotenuse <- function(a,b) {sqrt(a^2 + b^2)}
perimeter  <- function(a,b) {sum(a,b,hypotenuse(a,b))}

side_a <- NULL
side_b <- NULL
search_limit <- 1000

for (i in 1:search_limit) {
  for (j in 1:search_limit) {
    p = perimeter(i,j)
    h = hypotenuse(i,j)
    if (p > 1000 | h%%1!=0 | j %in% side_a) {
      next
    }
    side_a <- c(side_a, i)
    side_b <- c(side_b, j)
  }
  # print(i)
}

side_c <- hypotenuse(side_a, side_b)
all_sides <- rbind(side_a, side_b, side_c)
max_value <- max(colSums(all_sides))
max_index <- which(colSums(all_sides) == max_value)
all_sides[, max_index]



# PROBLEM 44
# ==========
# Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. 
# The first ten pentagonal numbers are:
#   
#   1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
# 
# It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, 
# their difference, 70 − 22 = 48, is not pentagonal.
# 
# Find the pair of pentagonal numbers, Pj and Pk, for which their 
# sum and difference are pentagonal and D = |Pk − Pj| is minimised;
# what is the value of D?

pentagon <- function(n) { n*(3*n-1)/2 }
pentagonal_num_100 <- pentagon(1:100)

index_K <- 1
found <- FALSE
limit <- 10000
pent_num <- pentagon(1:limit)

while (TRUE) {
  index_J <- index_K - 1
  
  while (index_J >= 1) {
    if (
      (pentagon(index_J)+pentagon(index_K)) %in% pent_num &
      (pentagon(index_K)-pentagon(index_J)) %in% pent_num
    ) {
      found <- TRUE
      break 
    } 
    index_J <- index_J - 1
  }
  
  if (found) {
    print(paste0("Pj = ", pentagon(index_J), ", where j = ", index_J))
    print(paste0("Pk = ", pentagon(index_K), ", where k = ", index_K))
    break
  }
  if (index_K >= limit) {
    print("not found")
    break
  }
  print(index_K)
  index_K <- index_K + 1
}

# Result
# [1] "Pj = 1560090, where j = 1020"
# [1] "Pk = 7042750, where k = 2167"


(pentagon(2167) + pentagon(1020)) %in% pent_num
(pentagon(2167) - pentagon(1020)) %in% pent_num

which(pent_num == pentagon(2167) + pentagon(1020))
pent_num[2395]
pentagon(2395)

which(pent_num == pentagon(2167) - pentagon(1020))
pent_num[1912]
pentagon(1912)


(pentagon(4) + pentagon(7)) %in% pentagon(1:100)
(pentagon(5) + pentagon(1)) %in% pentagon(1:100)


# First trial, but it was failed because I only checked 
# within the first 1000 pentagonal number
.pent_length <- 2395
pent_num <- pentagon(1:.pent_length)
check_result <- matrix(ncol = .pent_length, nrow = .pent_length)

for (j in 1:.pent_length) {      # j as a row index
  for (k in 1:.pent_length) {    # k as a column index
    if (k < j) {
      next
    }
    diff <- (pent_num[k] - pent_num[j]) %in% pent_num
    sum  <- (pent_num[k] + pent_num[j]) %in% pent_num
    check_result[j,k] <- sum & diff
  }
}

which(check_result == TRUE)
# 5188590
check_result[5188590]

# K = 2167; or ceiling(5188590 / 2395), round up since start from 1
# J = 1020; or 5188590 %% 2395
ceiling(5188590 / 2395)
5188590 %% 2395
check_result[1020, 2167]
